<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浩翰Redamancy的博客</title>
  
  <subtitle>一个爱学习的计算机菜鸟笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-13T12:31:52.110Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>精神小伙</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初识Spark</title>
    <link href="http://yoursite.com/2019/08/13/%E5%88%9D%E8%AF%86Spark/"/>
    <id>http://yoursite.com/2019/08/13/初识Spark/</id>
    <published>2019-08-13T12:12:40.000Z</published>
    <updated>2019-08-13T12:31:52.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spark简介"><a href="#Spark简介" class="headerlink" title="Spark简介"></a>Spark简介</h1><h2 id="Spark是什么"><a href="#Spark是什么" class="headerlink" title="Spark是什么"></a>Spark是什么</h2><p>Spark是一个快读且通用的集群计算平台</p><h2 id="Spark的特点"><a href="#Spark的特点" class="headerlink" title="Spark的特点"></a>Spark的特点</h2><p>Spark应用程序可以使用R语言、Java、Scala和Python进行编写，极少使用R语言编写Spark程序，Java和Scala语言编写的Spark程序的执行效率是相同的，但Java语言写的代码量多，Scala简洁优雅，但可读性不如Java，Python语言编写的Spark程序的执行效率不如Java和Scala。</p><h3 id="Spark是快速的"><a href="#Spark是快速的" class="headerlink" title="Spark是快速的"></a>Spark是快速的</h3><ul><li>Spark扩充了流行的MapReduce计算模型</li><li>Spark是基于内存的计算</li></ul><h3 id="Spark是通用的"><a href="#Spark是通用的" class="headerlink" title="Spark是通用的"></a>Spark是通用的</h3><ul><li>Spark的设计容纳了其他分布式系统拥有的功能</li><li>批处理，迭代式计算，交互查询和流处理等</li><li>优点：降低了维护成本</li></ul><h3 id="Spark是高度开放的"><a href="#Spark是高度开放的" class="headerlink" title="Spark是高度开放的"></a>Spark是高度开放的</h3><ul><li>Spark提供了Python，Java，Scala，Sql的API和丰富的内置库。</li><li>Spark和其他的大数据工具整合的很好，包括hadoop，kafka等</li></ul><h3 id="Spark有4中运行模式"><a href="#Spark有4中运行模式" class="headerlink" title="Spark有4中运行模式"></a>Spark有4中运行模式</h3><ul><li>local模式，适用于测试</li><li>standalone，并非是单节点，而是使用spark自带的资源调度框架</li><li>yarn，最流行的方式，使用yarn集群调度资源</li><li>mesos，国外使用的多</li></ul><h2 id="Spark生态"><a href="#Spark生态" class="headerlink" title="Spark生态"></a>Spark生态</h2><h3 id="Spark历史"><a href="#Spark历史" class="headerlink" title="Spark历史"></a>Spark历史</h3><p>Spark是美国加州大学伯克利分校的AMP实验室（主要创始人lester和Matei）开发的通用的大数据处理框架。</p><h3 id="Spark的组件"><a href="#Spark的组件" class="headerlink" title="Spark的组件"></a>Spark的组件</h3><p>Spark包括多个紧密集成的组件：</p><p><img src="image001.png" alt="Spark"></p><h4 id="Spark-Core："><a href="#Spark-Core：" class="headerlink" title="Spark Core："></a>Spark Core：</h4><p>包含Spark的基本功能，包含任务调度，内存管理，容错机制等。</p><p>内部定义了RDDs（弹性分布式数据集）。</p><p>提供了很多APIs来创建和操作这些RDDs。</p><p>应用场景:为其他组件提供底层的服务。</p><h4 id="Spark-SQL："><a href="#Spark-SQL：" class="headerlink" title="Spark SQL："></a>Spark SQL：</h4><p>是Spark处理结构化数据的库，就像Hive SQL，MySQL一样。</p><p>应用场景:企业中用来做报表统计</p><h4 id="Spark-Streaming："><a href="#Spark-Streaming：" class="headerlink" title="Spark Streaming："></a>Spark Streaming：</h4><p>是实时数据流处理组件，类似Storm。</p><p>Spark Streaming提供了API来操作实时流数据。</p><p>应用场景:企业中用来从kafka接受数据做实时统计。</p><h4 id="Milb："><a href="#Milb：" class="headerlink" title="Milb："></a>Milb：</h4><p>一个包含通用机器学习功能的包，Machine learning lib</p><p>包含分类，聚类，回归等，还包括模型评估，和数据导入</p><p>MLlib提供的上面的这些方法，都支持集群上的横向扩展</p><blockquote><p>平常我们做机器学习用Python较多，Python最大的缺点是在单机上的，它处理的数据是有限的，而Milb是基于集群的</p></blockquote><p>应用场景，机器学习</p><h4 id="Graphx："><a href="#Graphx：" class="headerlink" title="Graphx："></a>Graphx：</h4><p>是处理图的库（例如，社交网络图），并进行图的并行计算。</p><p>像Spark Streaming，Spark SQL一样，它也继承了RDD API。</p><p>它提供了各种图的操作，和常用的图算法，例如PageRank算法。</p><p>应用场景，图计算。</p><h4 id="Cluster-Managers："><a href="#Cluster-Managers：" class="headerlink" title="Cluster Managers："></a>Cluster Managers：</h4><p>就是集群管理，Spark自带一个集群管理是单独调度器。</p><p>常见集群管理包括Hadoop YARN，Apache Mesos</p><p>紧密继承的优点：</p><ul><li>Spark底层优化了，基于Spark底层的组件，也得到了相应的优化。</li><li>紧密集成，节省了各个组件结合使用时的部署，测试等时间。</li><li>向Spark增加新的组件时，其他组件，可立即享用新组建的功能</li></ul><h2 id="Spark与Hadoop的比较"><a href="#Spark与Hadoop的比较" class="headerlink" title="Spark与Hadoop的比较"></a>Spark与Hadoop的比较</h2><h3 id="Hadoop的应用场景"><a href="#Hadoop的应用场景" class="headerlink" title="Hadoop的应用场景"></a>Hadoop的应用场景</h3><h4 id="离线处理"><a href="#离线处理" class="headerlink" title="离线处理"></a>离线处理</h4><p>Hadoop在处理数据的时候它的中间数据会落到硬盘上，因此导致Hadoop处理大量数据时时效性不是很高。</p><p>Hadoop任务的执行时间是几分钟到几小时不等</p><p>对时效性要求不高</p><h4 id="Spark应用场景"><a href="#Spark应用场景" class="headerlink" title="Spark应用场景"></a>Spark应用场景</h4><p>时效性要求高的场景</p><p>因为Spark是基于内存的，它的中间数据尽量不落在磁盘上，尽量落在内存中，这样就大大加快了Spark的运算速度</p><p>Spark的计算时间一般是几秒钟到几分钟</p><p>机器学习等领域</p><ul><li>这是一整个生态系统，每个组件都有其作用，各善其职即可</li><li>Spark不具有HDFS的存储能力，要借助HDFS等持久化数据</li><li>大数据将会孕育出更多的新技术</li></ul><h3 id="RDDs介绍"><a href="#RDDs介绍" class="headerlink" title="RDDs介绍"></a>RDDs介绍</h3><h4 id="Driver-program："><a href="#Driver-program：" class="headerlink" title="Driver program："></a>Driver program：</h4><p>包含程序的main（）方法，RDDs的定义和操作。<br>它管理很多节点，我们称作<code>executors</code></p><p><img src="image003.png" alt="Spark"></p><h4 id="SparkContext："><a href="#SparkContext：" class="headerlink" title="SparkContext："></a>SparkContext：</h4><p>Driver programs通过SparkContext对象访问Spark。</p><p>SparkContext对象代表和一个集群的连接。</p><p>在Shell中SparkContext自动创建好了，就是sc。</p><h4 id="RDDs："><a href="#RDDs：" class="headerlink" title="RDDs："></a>RDDs：</h4><p>Resilient distributed datasets（弹性分布式数据集，简写RDDs）</p><p>这些RDDs，并行的分布在整个集群中</p><p>RDDs是Spark分发数据和计算的基础抽象类。</p><p>一个RDD是一个不可改变的分布式集合对象</p><p>Spark中，所有的计算都是通过RDDs的创建，转换，操作完成的。</p><p>一个RDD内部由许多partitions（分片）组成。</p><h5 id="分片："><a href="#分片：" class="headerlink" title="分片："></a>分片：</h5><p>每个分片包括一部分数据，partitions可在集群不同节点上计算</p><p>分片是Spark并行处理的单元，Spark顺序的，并行的处理分片</p><h5 id="RDDs的创建方法："><a href="#RDDs的创建方法：" class="headerlink" title="RDDs的创建方法："></a>RDDs的创建方法：</h5><p>把一个存在的集合传给SparkContext的parallelize()方法，测试用</p><p><code>val rdd = sc.parallelize(Array(1,2,2,4),4)</code></p><p>第一个参数：待并行化处理的集合，第二个参数：分区个数</p><p>加载外部数据集。</p><p><code>val rddText = sc.textFile(&quot;helloSpark.txt&quot;)</code></p><h2 id="Scala的基础知识"><a href="#Scala的基础知识" class="headerlink" title="Scala的基础知识"></a>Scala的基础知识</h2><h3 id="Scala的变量声明："><a href="#Scala的变量声明：" class="headerlink" title="Scala的变量声明："></a>Scala的变量声明：</h3><p>在Scala中创建变量的时候，必须使用val或者var</p><p>val，变量值不可修改，一旦分配不能重新指向别的值</p><p>var，分配后，可以指向类型相同的值</p><h3 id="Scala的匿名函数和类型推断："><a href="#Scala的匿名函数和类型推断：" class="headerlink" title="Scala的匿名函数和类型推断："></a>Scala的匿名函数和类型推断：</h3><p><code>lines.filter(line=&gt;line.contains(&quot;world&quot;))</code></p><p>定义一个匿名函数，接受一个参数line，</p><p>使用line这个String类型变量上的contains方法，并且返回结果。</p><p>line的类型不需指定，能够推断出来。</p><h2 id="RDD基本操作之Transformation"><a href="#RDD基本操作之Transformation" class="headerlink" title="RDD基本操作之Transformation"></a>RDD基本操作之Transformation</h2><h3 id="Transformation介绍："><a href="#Transformation介绍：" class="headerlink" title="Transformation介绍："></a>Transformation介绍：</h3><h4 id="Transformations（转换）"><a href="#Transformations（转换）" class="headerlink" title="Transformations（转换）"></a>Transformations（转换）</h4><p>从之前的RDD构建一个新的RDD，像map()和filter().</p><h4 id="map"><a href="#map" class="headerlink" title="map():"></a>map():</h4><p>map()接受函数，把函数应用到RDD的每一个元素，返回新RDD。</p><h4 id="filter"><a href="#filter" class="headerlink" title="filter():"></a>filter():</h4><p>filter()接受函数，返回只包含满足filter()函数的元素的新RDD。</p><h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap():"></a>flatMap():</h4><p>对每个输入元素，输出多个输出元素。</p><p>flat压扁的意思，将RDD中元素压扁后返回一个新的RDD.</p><h2 id="RDD基本操作之Action"><a href="#RDD基本操作之Action" class="headerlink" title="RDD基本操作之Action"></a>RDD基本操作之Action</h2><h3 id="Action介绍："><a href="#Action介绍：" class="headerlink" title="Action介绍："></a>Action介绍：</h3><p>在RDD上计算出来一个结果。</p><p>把结果返回给driver program或保存在文件系统，count(),save</p><p><img src="image005.png" alt="Spark"></p><p><img src="image007.png" alt="Spark"></p><h3 id="常用函数举例："><a href="#常用函数举例：" class="headerlink" title="常用函数举例："></a>常用函数举例：</h3><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h4><p>接收一个函数，作用在RDD两个类型相同的元素上，返回新元素。<br>可以实现，RDD中元素的累加，计数，和其他类型的聚集操作。</p><p><img src="image009.png" alt="Spark"></p><p><img src="image011.png" alt="Spark"></p><h4 id="Collect-："><a href="#Collect-：" class="headerlink" title="Collect()："></a>Collect()：</h4><p>遍历整个RDD，向driver program返回RDD的内容</p><p>需要单机内存能够容纳下（因为数据要拷贝给driver，测试使用）</p><p>大数据的时候，使用savaAsTextFile() action等。</p><h4 id="take-n-："><a href="#take-n-：" class="headerlink" title="take(n)："></a>take(n)：</h4><p>返回RDD的n个元素（同时尝试访问最少的partitions）</p><p>返回结果是无序的，测试使用</p><h4 id="top-："><a href="#top-：" class="headerlink" title="top()："></a>top()：</h4><p>排序（根据RDD中数据的比较器）</p><h4 id="foreach-："><a href="#foreach-：" class="headerlink" title="foreach()："></a>foreach()：</h4><p>计算RDD中的每个元素，但不返回到本地。</p><p>可以配合println()友好的打印出数据。</p><h2 id="RDDs的特性"><a href="#RDDs的特性" class="headerlink" title="RDDs的特性"></a>RDDs的特性</h2><p><strong>RDDs的血统关系图：</strong></p><p><img src="image013.png" alt="Spark"></p><p>Spark维护者RDDs之间的依赖关系和创建关系，叫做血统关系图</p><p>Spark使用血统关系图来计算每个RDD的需求和恢复丢失的数据</p><h3 id="延迟计算（Lazy-Evaluation）："><a href="#延迟计算（Lazy-Evaluation）：" class="headerlink" title="延迟计算（Lazy Evaluation）："></a>延迟计算（Lazy Evaluation）：</h3><p>Spark对RDDs的计算是，他们第一次使用action操作的时候</p><p>这种方式在处理大数据的时候特别有用，可以减少数据的传输</p><p>Spark内部记录metadata表名transformations操作已经被响应了</p><p>加载数据也是延迟计算，数据只有在必要的时候，才会被加载进去</p><h3 id="RDD-persist"><a href="#RDD-persist" class="headerlink" title="RDD.persist():"></a>RDD.persist():</h3><p>默认每次在RDDs上面进行action操作时，Spark都重新计算RDDs</p><p>如果想重复利用一个RDD，可以使用RDD.persist()</p><p>unpersist()方法从缓存中移除</p><p>例子-peisist()</p><p><img src="image015.png" alt="Spark"></p><p><img src="image017.png" alt="Spark"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spark简介&quot;&gt;&lt;a href=&quot;#Spark简介&quot; class=&quot;headerlink&quot; title=&quot;Spark简介&quot;&gt;&lt;/a&gt;Spark简介&lt;/h1&gt;&lt;h2 id=&quot;Spark是什么&quot;&gt;&lt;a href=&quot;#Spark是什么&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="Spark" scheme="http://yoursite.com/categories/Spark/"/>
    
    
      <category term="Spark" scheme="http://yoursite.com/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>Java中“==”与equeals的区别</title>
    <link href="http://yoursite.com/2019/08/13/Java%E4%B8%AD%E2%80%9C-%E2%80%9D%E4%B8%8Eequeals%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/08/13/Java中“-”与equeals的区别/</id>
    <published>2019-08-13T11:58:48.000Z</published>
    <updated>2019-08-13T12:10:31.501Z</updated>
    
    <content type="html"><![CDATA[<h2 id="："><a href="#：" class="headerlink" title="==："></a>==：</h2><p><code>==</code>是比较两个变量的值，如果是基本数据类型，那么就是比较的基本数据的大小值</p><h3 id="情况一："><a href="#情况一：" class="headerlink" title="情况一："></a>情况一：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">1</span>;</span><br><span class="line">System.out.println(a==b);</span><br></pre></td></tr></table></figure><p><img src="image001.png" alt="Java"></p><p>以上图中：==比较的就是上面两个内存块中的值，都是1，所以是true</p><p>但是如果存储的是引用类型，其实比较的还是变量本身所存储的值，我们都知道，<br>变量存储引用类型其实存储的只是引用对象的地址作为值存储到变量中，那么当用==<br>判断时，比较的就是这两个<strong>地址值</strong>了，所以说==比的是两个变量所存储的值，</p><p>至于这个值是什么类型的，就看放什么了</p><h3 id="情况二："><a href="#情况二：" class="headerlink" title="情况二："></a>情况二：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User a = <span class="keyword">new</span> User();</span><br><span class="line">User b = <span class="keyword">new</span> User();</span><br><span class="line">System.out.println(a==b);</span><br></pre></td></tr></table></figure><p><img src="image003.png" alt="Java"></p><p>在上图中，a和b存的就是一个引用对象，在这时判断a==b时，比较的也是a和b所存储的值，</p><p>可以看出，a里面存的是0x1234，b里面存放的是0x5874,很明显不相等，所以是false</p><h3 id="情况三："><a href="#情况三：" class="headerlink" title="情况三："></a>情况三：</h3><p>而当使用==比较字符串时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a=<span class="string">"abcd"</span>;</span><br><span class="line">String b=<span class="string">"abcd"</span>;</span><br><span class="line">System.out.println(a==b);</span><br></pre></td></tr></table></figure><p><img src="image005.png" alt="Java"></p><p>这时，a和b存储的是同一个常量字符串，地址也一样，所以是true。</p><p>情况四：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a=<span class="keyword">new</span> String(<span class="string">"abcd"</span>);</span><br><span class="line">String b=<span class="keyword">new</span> String(<span class="string">"abcd"</span>);</span><br><span class="line">System.out.printlnl(a==b);</span><br></pre></td></tr></table></figure><p><img src="image007.png" alt="Java"></p><p>如果通过创建对象的方式创建字符串，那么流程就会向上图一样，a和b里面所存放的值就不一样了，a和b 比较就是false</p><h2 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h2><p>JAVA当中所有的类都是继承于<code>Object</code>这个超类的，在Object类中定义了一个equals的方法，equals的源码是这样写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//this - s1</span></span><br><span class="line">    <span class="comment">//obj - s2</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个方法的初始默认行为是比较对象的内存地址值，一般来说，意义不大。所以，在一些类库当中这个方法被重写了，如String、Integer、Date。在这些类当中equals有其自身的实现（一般都是用来比较对象的成员变量值是否相同），而不再是比较类在堆内存中的存放地址了。</p><p>所以说，对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是内存中的存放位置的地址值，跟双等号（==）的结果相同；如果被复写，按照复写的要求来。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  String s1 = "a";</span></span><br><span class="line"><span class="comment">    String s2 = "b";</span></span><br><span class="line"><span class="comment">    String s3 = "c";</span></span><br><span class="line"><span class="comment">    String s4 = "abc";</span></span><br><span class="line"><span class="comment">    String s5 = s1+s2+s3;</span></span><br><span class="line"><span class="comment">    System.out.println(s4 == s5);</span></span><br><span class="line"><span class="comment">    System.out.println(s4.equals(s5));</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    String s1 = <span class="string">"a"</span> + <span class="string">"b"</span> + <span class="string">"c"</span>;</span><br><span class="line">    String s2 = <span class="string">"abc"</span>;</span><br><span class="line">    System.out.println(s1 == s2);</span><br><span class="line">    System.out.println(s1.equals(s2));</span><br></pre></td></tr></table></figure><p>地址值的话，由于String是常量，存放于常量池中。而Java中对于常量有常量优化机制，所以没有注释的部分，在编译时候，就是将abc相加的结果赋值给s1，又发现常量池中已经有了abc，所以s1和s2指向的是常量池中的同一个abc，而注释的部分，由于是变量相加，运行时会在常量池中创建新的abc，所以是两个不同的abc</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;：&quot;&gt;&lt;a href=&quot;#：&quot; class=&quot;headerlink&quot; title=&quot;==：&quot;&gt;&lt;/a&gt;==：&lt;/h2&gt;&lt;p&gt;&lt;code&gt;==&lt;/code&gt;是比较两个变量的值，如果是基本数据类型，那么就是比较的基本数据的大小值&lt;/p&gt;
&lt;h3 id=&quot;情况一：&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java编程思想学习笔记(二)</title>
    <link href="http://yoursite.com/2019/08/10/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/"/>
    <id>http://yoursite.com/2019/08/10/Java编程思想学习笔记-二/</id>
    <published>2019-08-10T02:50:06.000Z</published>
    <updated>2019-08-10T05:39:23.991Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初始化与清理"><a href="#初始化与清理" class="headerlink" title="初始化与清理"></a>初始化与清理</h1><blockquote><p>随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主因之一,初始化与清理正是涉及安全的两个问题。</p></blockquote><p>许多c程序的错误都源于程序员忘记初始化变量。清理也是一个特殊问题，当使用完一个元素时，它对你也就不会有什么影响了，所以很容易把它忘记。这样一来，这个元素占有的资源就会一直得不到释放，结果是资源（尤其是内存）用尽。</p><p>Java中采用了<strong>构造器</strong>，这是一个在创建对象时被自动调用的特殊方法，并额外提供了“垃圾回收器”。对于不再使用的内存资源，垃圾回收器能自动将其释放。</p><h2 id="用构造器确保初始化"><a href="#用构造器确保初始化" class="headerlink" title="用构造器确保初始化"></a>用构造器确保初始化</h2><p>可以假想为编写的每个类都定义一个<code>initialize()</code>方法。</p><p>该方法的名称题型你在使用其对象之前，应首先调用<code>initialize()</code></p><p>在Java中，通过提供构造器，类的设计者可确保每个对象都会得到初始化。创建对象时，如果其类具有构造器，Java就会在用户有能力操作对象之前自动调用相应的构造器，从而保证了初始化的进行。</p><h3 id="如何命名"><a href="#如何命名" class="headerlink" title="如何命名"></a>如何命名</h3><p>构造器采用与类相同的名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rock</span> </span>&#123;</span><br><span class="line">    Rock() &#123;</span><br><span class="line">        System.out.print(<span class="string">"Rock "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Rock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    Rock Rock Rock Rock Rock Rock Rock Rock Rock Rock</span><br></pre></td></tr></table></figure><p>现在，在创建对象时：</p><p><code>new Rock();</code></p><p>将会为对象分配存储空间，并调用相应构造器。</p><p>不接受任何参数的构造器叫做<strong>默认构造器</strong>。和其他方法一样，构造器也能带有形式参数，以便指定如何创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rock2</span> </span>&#123;</span><br><span class="line">    Rock2(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        System.out.print(<span class="string">"Rock "</span> + i + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Rock2(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">    Rock <span class="number">0</span> Rock <span class="number">1</span> Rock <span class="number">2</span> Rock <span class="number">3</span> Rock <span class="number">4</span> Rock <span class="number">5</span></span><br></pre></td></tr></table></figure><p>有了构造器形式参数，就可以在初始化对象时提供实际参数。例如假设类Tree有一个构造器，它接受一个整型变量来表示数的高度</p><p><code>Tree t = new Tree(12);</code></p><p>如果<code>Tree(int)</code>是<code>Tree</code>类中唯一的构造器，那么编译器将不会允许你以其他任何方式创建<code>Tree</code>对象。</p><p>构造器有助于减少错误，并且使代码更易于阅读。<strong>在Java中，“初始化”和“创建”捆绑在一起，两者不能分离</strong></p><p>构造器是一种特殊类型的方法，因为它没有返同值。</p><p>这与返回值为空(void)明显不同。对于空返回值，尽管方法本身不会自动返回什么，但仍可选择让它返回别的东西。</p><p>构造器则不会返回任何东西，你别无选择(new表达式确实返回了对新建对象的引用，但构造器本身并没有任何返回值)。假如构造器具有返回值，并且允许人们自行选择返回类型，那么势必得让编译器知道该如何处理此返回值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;初始化与清理&quot;&gt;&lt;a href=&quot;#初始化与清理&quot; class=&quot;headerlink&quot; title=&quot;初始化与清理&quot;&gt;&lt;/a&gt;初始化与清理&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主因之一,初始化
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java编程思想学习笔记</title>
    <link href="http://yoursite.com/2019/08/10/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/08/10/Java编程思想学习笔记/</id>
    <published>2019-08-10T02:42:19.000Z</published>
    <updated>2019-08-10T02:50:29.713Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对象导论"><a href="#对象导论" class="headerlink" title="对象导论"></a>对象导论</h1><h2 id="抽象过程"><a href="#抽象过程" class="headerlink" title="抽象过程"></a>抽象过程</h2><p>所有编程语言都提供抽象机制。<br>万物皆为对象<br>程序是对象的集合，它们通过发送消息来告知彼此所要做的。<br>每个对象都有自己的由其他对象所构成的存储<br>每个对象都拥有其类型<br>某一特定类型的所有对象都可以接受同样的消息<br>对象具有状态，行为和标识</p><h2 id="每个对象都有一个接口"><a href="#每个对象都有一个接口" class="headerlink" title="每个对象都有一个接口"></a>每个对象都有一个接口</h2><p>怎样才能获取有用的对象？必须有某种方式产生对对象的请求，是对象完成各种任务，如完成一笔交易，在屏幕上画图，打开开关等。每个对象都只能满足某些请求，这些请求有对象的接口（interface）所定义，决定接口的便是类型。<br>以电灯泡为例来做一个简单的比喻：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Light lt = <span class="keyword">new</span> Litght();</span><br><span class="line">lt.on();</span><br></pre></td></tr></table></figure><p><strong>接口确定了对某一特定对象所能发出的请求。</strong></p><p>上例中，类型/类的名称是Light，特定的Light对象的名词是It，可以向Light对象发出的请求是：打开它，关闭它，将它调亮，将它调暗。你以下列方式创建了一个Light对象：定义这个对象的‘引用’(It)，然后调用new方法来创建该类型的新对象。为了向对象发送消息，需要声明对象的名称，并以圆点符号连接一个消息请求。</p><h2 id="每个对象都提供服务"><a href="#每个对象都提供服务" class="headerlink" title="每个对象都提供服务"></a>每个对象都提供服务</h2><p>程序本身将向用户提供服务，他将通过调用其他对象提供的服务来实现这一目的。</p><h2 id="被隐藏的具体实现"><a href="#被隐藏的具体实现" class="headerlink" title="被隐藏的具体实现"></a>被隐藏的具体实现</h2><p>java用三个关键字在类的内部设定边界，public，private，protected<br>java还有一种默认的访问权限，当没有使用前面提到的任何访问指定词时，它将发挥作用。这种权限通常被称为包访问权限</p><h2 id="复用具体实现"><a href="#复用具体实现" class="headerlink" title="复用具体实现"></a>复用具体实现</h2><p>代码复用是面向对象程序设计语言所提供的的最了不起的优点之一。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>当继承现有类型时，也就创造了新的类型。这个新的类型不仅包括现有类型的所有成员（尽管private成员被隐藏，并且不可访问），而且更重要的是它复制了基类的接口。也就是说，所有可以发送给基类对象的消息同时也可以发送给导出类对象。导出类与基类具有相同的类型。</p><p>一个圆形也是一个几何形。</p><p>有两种方法可以使基类与导出类产生差异。<br>直接在导出类中添加新方法，这个新方法并不是基类接口的一部分。<br>覆改变现有基类的方法，覆盖。</p><h2 id="伴随多态的可互换对象"><a href="#伴随多态的可互换对象" class="headerlink" title="伴随多态的可互换对象"></a>伴随多态的可互换对象</h2><p>面向对象程序设计的最重要的妙诀:编译器不可能产生传统意义上的函数调用。</p><p>如果用Java来编写一个方法(后面很快你就会学习如何编写):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Shape shape)</span></span>&#123;</span><br><span class="line">    shape.erase();</span><br><span class="line">    shape.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法可以与任何Shape对话，因此它是独立于任何它要绘制和擦除的对象的其体类型的。</p><p>如果程序中其他部分用到了doSomething()方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Circle CirCie，<span class="keyword">new</span> Circle();</span><br><span class="line">Triangle triangle = <span class="keyword">new</span> triangle();</span><br><span class="line">Line line = <span class="keyword">new</span> Line():</span><br><span class="line">doSomething(circle);</span><br><span class="line">doSomething(triangle);</span><br><span class="line">doSomething(line);</span><br></pre></td></tr></table></figure><p>对doSomething()的调用会白动地正确处理，而不管对象的确切类型。</p><p>这是一个相当令人惊奇的诀窍。看看下面这行代码:</p><p><code>doSomething(circle);</code></p><p>当Circle被传入到预期接收Shape的方法中，究竟会发生什么。由于Circle可以被doSomething() 看作是Shape，也就是说，doSomething()可以发送给Shape的任何消息，Circle都可以接收，那么，这么做是完全安全且合乎逻辑的。</p><h2 id="单根继承结构"><a href="#单根继承结构" class="headerlink" title="单根继承结构"></a>单根继承结构</h2><p>在OOP中，自c++面世以来就己变得非常瞩目的一个问题就是，是否所有的类最终都继承自单一的基类。在java中(事实上还包括除C++以外的所有OOP语言)，答案是yes，这个终极基类的名字就是<strong>Object</strong>。事实证明，单根继承结构带来了很多好处。</p><p>在单根继承结构中的所有对象都具有一个共用接口，所以它们归根到底都是相同的基本类型。</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>这个通常被称为容器(也称为集合，不过Java类库以不同的含义使用“集合”这个术语，所以本书使用“容器”这个词)的新对象，在任何需要时都可扩充自己以容纳你置于其中的所有东西。因此不需要知道将来会把多少个对象置于容器中，只需要创建一个容器对象，然后让它处理所有细节。</p><h2 id="对象的创建和生命期"><a href="#对象的创建和生命期" class="headerlink" title="对象的创建和生命期"></a>对象的创建和生命期</h2><p>在使用对象时，最关键的问题之一便是他们的生成和销毁方式。每个对象为了生存都需要资源，尤其是内存。当我们不再需要一个对象时，它必须被清理掉，使其占有的资源被释放和重用。</p><p>Java完全采用了动态内存分配方式。每当想要创建新对象时，就要使用new关键字来构建此对象的动态实例。</p><p>Java提供了<strong>垃圾回收器</strong>的机制，它可以自动发现对象何时不再被使用，并继而销毁它。</p><h2 id="异常处理：处理错误"><a href="#异常处理：处理错误" class="headerlink" title="异常处理：处理错误"></a>异常处理：处理错误</h2><p> 异常处理将错误处理直接置于编程语言中，有时甚至置于操作系统中。异常是一种对象，它从出错地点被“抛出’，并被专门设计用来处理特定类型错误的相应的异常处理器“捕获”。异常处理就像是与程序正常执行路径并行的、在错误发生时执行的另一条路径。因为它是另一条完全分离的执行路径，所以它不会干扰正常的执行代码。这往往使得代码编写变得简单，因为不需要被迫定期检查错误。</p><p>此外，被抛出的异常不像方法返回的错误值和方法设置的用来表示错误条件的标志位那样可以被忽略。异常不能被忽略，所以它保证一定会在某处得到处理。</p><p>最后需要指出的是：异常提供了一种从错误状况进行可靠恢复的途径。现在不再是只能退出程序，你可以经常进行校正，并恢复程序的执行，这些都有助于编写出更健壮的程序。<br>Java的异常处理在众多的编程语言中格外引人注目，因为Java一开始就内置了异常处理，而且强制你必须使用它。</p><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><p>在计算机编程中有一个基本概念。就是在同一时刻处理多个任务的思想。许多程序设计问题都要求，程序能够停下正在做的工作，转而处理某个其他问题。然后再返回主进程。</p><p>有时中断对于处理时间性强的任务是必需的，但是对于大量的其他问题，我们只是想把问题切分成多个可独立运行的部分(任务)，从而提高程序的响应能力。在程序中，这些彼此独立运行的部分称之为线程，上述概念被称为“并发”。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>你知道过程型语一言看起来像什么样子：数据定义和函数调用。想了解此类程序的含义，你必须忙上一阵，需要通读函数调用和低层概念，以在脑海里建立一个模型。这正是我们在设计过程式程序时，需要中间表示形式的原因。这些程序总是容易把人搞糊涂，因为它们使用的表示术语更加面向计算机而不是你要解决的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;对象导论&quot;&gt;&lt;a href=&quot;#对象导论&quot; class=&quot;headerlink&quot; title=&quot;对象导论&quot;&gt;&lt;/a&gt;对象导论&lt;/h1&gt;&lt;h2 id=&quot;抽象过程&quot;&gt;&lt;a href=&quot;#抽象过程&quot; class=&quot;headerlink&quot; title=&quot;抽象过程&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop2.8.0的环境搭建</title>
    <link href="http://yoursite.com/2019/08/09/Hadoop2-8-0%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2019/08/09/Hadoop2-8-0的环境搭建/</id>
    <published>2019-08-09T11:12:44.000Z</published>
    <updated>2019-08-10T02:41:31.066Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此文为在centos7下安装Hadoop集群</p></blockquote><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><blockquote><p><a href="www.apache.org/dyn/closer.cgi/hadoop/common/hadoop-2.8.0/hadoop-2.8.0.tar.gz">Hadoop下载</a></p></blockquote><h3 id="Hadoop的下载"><a href="#Hadoop的下载" class="headerlink" title="Hadoop的下载"></a>Hadoop的下载</h3><blockquote><p>本文下载的是2.8.0版本的Hadoop</p></blockquote><p><img src="image001.png" alt="Hadoop"></p><h3 id="安装3个虚拟机并实现ssh免密码的登录"><a href="#安装3个虚拟机并实现ssh免密码的登录" class="headerlink" title="安装3个虚拟机并实现ssh免密码的登录"></a>安装3个虚拟机并实现ssh免密码的登录</h3><h4 id="安装3个centos7虚拟机"><a href="#安装3个centos7虚拟机" class="headerlink" title="安装3个centos7虚拟机"></a>安装3个centos7虚拟机</h4><p>安装方法：</p><p>安装3个机器，机器分别叫<strong>master slave1 slave2</strong></p><p>如图：</p><p><img src="image003.png" alt="Hadoop"></p><p><strong>ps：为了免去后面一系列授权的麻烦，这里直接使用root账户登录和操作了。</strong></p><p>使用ifconfig命令，查看着三台机器的ip。</p><p>我的机器名与ip 的对应的关系是：</p><pre><code>192.168.236.132 master192.168.236.133 slave1192.168.236.134 slave2</code></pre><h4 id="检查机器名称"><a href="#检查机器名称" class="headerlink" title="检查机器名称"></a>检查机器名称</h4><p>为了后续操作方便，确保机器的hostname是我们想要的。拿192.168.236.132机器举例，用root账户登录之后，然后使用<code>hostname</code>命令查看机器名称</p><p>如图：</p><p><img src="image005.png" alt="Hadoop"></p><p>hostname命令查看名称一开始的名称是localhost </p><p>我们用hostname master命令更改机器名称为master</p><h4 id="修改-etc-hosts文件"><a href="#修改-etc-hosts文件" class="headerlink" title="修改/etc/hosts文件"></a>修改/etc/hosts文件</h4><p>修改这3台机器的/etc/hosts文件，在文件中添加以下内容：<br>    192.168.236.132 master<br>    192.168.236.133 slave1<br>    192.168.236.134 slave2<br>如图：</p><p><img src="image007.png" alt="Hadoop"></p><p>说明：ip地址没必要和我的一样，这里只是做一个映射，只要映射是对的就可以，至于修改方法，vi vim 命令都可以。</p><p>配置成功后使用 ping 命令检查者3台机器是否相互ping的通，以master为例，：</p><p><img src="image009.png" alt="Hadoop"></p><p>说明能够ping通</p><blockquote><p>使用该命令 在各个机器都尝试是否可以ping通,ping得通，说明机器是互联的，而且hosts配置也正确。</p></blockquote><h4 id="给3个机器生成秘钥文件"><a href="#给3个机器生成秘钥文件" class="headerlink" title="给3个机器生成秘钥文件"></a>给3个机器生成秘钥文件</h4><p>以master为例，执行命令，生成空字符串的秘钥（后面要使用公钥），命令是：</p><p><code>ssh-keygen -t rsa</code></p><p>如图：</p><p><img src="image011.png" alt="Hadoop"></p><p>因为我现在使用的是root账户，所以秘钥文件保存到了/root/.shh/目录内，可以使用命令查看，命令是：</p><p><code>cd  /root/.ssh</code></p><p>然后<code>ls</code></p><p>如图：</p><p><img src="image013.png" alt="Hadoop"></p><p>使用相同的方法为slave1与slave2生成秘钥（命令相同，不用做任何修改）。</p><h4 id="在master上创建authorized-keys文件"><a href="#在master上创建authorized-keys文件" class="headerlink" title="在master上创建authorized_keys文件"></a>在master上创建authorized_keys文件</h4><p>接下来要做的事情就是在3台机器的/root/.shh/目录下都存入一个内容相同的文件，文件名称叫<strong>authorized_keys</strong>，文件内容是我们刚才为3台机器生成的公钥。</p><p>为了方便，我下面的步骤是现在master上生成<strong>authorized_keys</strong>文件，然后把3台机器刚才生成的公钥加入到这个master的authorized_keys文件里，然后在将这个authorize_keys文件复制到slave1与slave2里。</p><p>首先使用命令，在master的/root/.ssh/目录中生成一个名为authorized_keys的文件，命令是：</p><p><code>touch /root/.shh/authorized_keys</code></p><p>如图：</p><p><img src="image015.png" alt="Hadoop"></p><blockquote><p>因为我已经在.ssh目录中了，所以直接在该目录打 touch authorized_keys 命令就可以</p></blockquote><p>其次将master上的/root/.ssh/id_rsa.pub文件内容，slave1上的/root/.ssh/id_rsa.pub文件内容，slave2上的/root/.ssh/id_rsa.pub文件内容复制到这个authorized_keys文件中.</p><p>复制的方法很多了，可以用cat命令和vim命令结合来弄，也可以直接把这3台机器上的/root/.ssh/id_rsa.pub文件下载到本地，在本地将authorized_keys文件编辑好在上载到这3台机器上。master机器上我的/root/.ssh/id_rsa.pub内容是:</p><p>如图：</p><p><img src="image017.png" alt="Hadoop"></p><p>先将master的id_rsa.pub加到authorized_keys中：</p><p><img src="image019.png" alt="Hadoop"></p><p>然后将slave1与slave2中的d_rsa.pub复制到master的authorized_keys中</p><p>如图：</p><p><img src="image21.png" alt="Hadoop"></p><h4 id="将authorized-keys文件复制到其他机器"><a href="#将authorized-keys文件复制到其他机器" class="headerlink" title="将authorized_keys文件复制到其他机器"></a>将authorized_keys文件复制到其他机器</h4><p> master器的/root/.ssh/目录下已经有authorized_keys这个文件了，该文件的内容也已经OK了，接下来要将该文件复制到slave1的/root/.ssh/和slave2的/root/.ssh/。</p><p><img src="image023.png" alt="Hadoop"></p><p>（输入yes）</p><h4 id="测试使用ssh进行无密码登录"><a href="#测试使用ssh进行无密码登录" class="headerlink" title="测试使用ssh进行无密码登录"></a>测试使用ssh进行无密码登录</h4><p>输入命令：</p><p><code>ssh slave1</code></p><p>如图：</p><p><img src="image025.png" alt="Hadoop"></p><p>显示这样便就是连接成功，exit 命令退出</p><p>接下来便在 slave1与slave2中测试</p><h3 id="安装Jdk与Hadoop"><a href="#安装Jdk与Hadoop" class="headerlink" title="安装Jdk与Hadoop"></a>安装Jdk与Hadoop</h3><p>说明，为了省去一系列获取管理员权限，授权等繁琐操作，精简教程，这里都是使用root账户登录并且使用root权限进行操作。</p><h4 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a>安装jdk</h4><p>安装：<br>    可以参考我的<a href="https://plutoacharon.github.io/2019/07/31/Centos7%E4%B8%8B%E7%9A%84JDK%E5%AE%89%E8%A3%85/#more" target="_blank" rel="noopener">Centos7下的Jdk安装</a></p><h4 id="安装hadoop"><a href="#安装hadoop" class="headerlink" title="安装hadoop"></a>安装hadoop</h4><p><strong>注意：3台机器都要解压安装</strong></p><h5 id="上载文件并解压缩"><a href="#上载文件并解压缩" class="headerlink" title="上载文件并解压缩"></a>上载文件并解压缩</h5><p>在opt目录下新建一个名为hadoop的目录，并将下载得到的hadoop-2.8.0.tar上载到该目录下，如图:</p><p><img src="image027.png" alt="Hadoop"></p><p><strong>（此处使用的是xftp6）</strong></p><p>然后进入到该目录，执行命令：</p><p><code>cd /opt/hadoop</code></p><p>执行解压命令：</p><p><code>tar -zxvf hadoop-2.8.0.tar.gz</code></p><p>说明：3台机器都要进行上述操作，解压缩后得到一个名为hadoop-2.8.0的目录</p><h5 id="新建几个目录"><a href="#新建几个目录" class="headerlink" title="新建几个目录"></a>新建几个目录</h5><pre><code>mkdir  /root/hadoop  mkdir  /root/hadoop/tmp  mkdir  /root/hadoop/var  mkdir  /root/hadoop/dfs  mkdir  /root/hadoop/dfs/name  mkdir  /root/hadoop/dfs/data</code></pre><h5 id="修改etc-hadoop中的一系列配置文件"><a href="#修改etc-hadoop中的一系列配置文件" class="headerlink" title="修改etc/hadoop中的一系列配置文件"></a>修改etc/hadoop中的一系列配置文件</h5><p><strong>修改core-site.xml</strong></p><p> 修改/opt/hadoop/hadoop-2.8.0/etc/hadoop/core-site.xml文件</p><pre><code>        在&lt;configuration&gt;节点内加入配置:&lt;property&gt;        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;        &lt;value&gt;/root/hadoop/tmp&lt;/value&gt;        &lt;description&gt;Abase for other temporary directories.&lt;/description&gt;&lt;/property&gt;&lt;property&gt;        &lt;name&gt;fs.default.name&lt;/name&gt;        &lt;value&gt;hdfs://master:9000&lt;/value&gt;&lt;/property&gt;</code></pre><p><strong>修改hadoop-env.sh</strong></p><p>修改/opt/hadoop/hadoop-2.8.0/etc/hadoop/hadoop-env.sh文件</p><pre><code>将export   JAVA_HOME=${JAVA_HOME}修改为：export   JAVA_HOME=/opt/java/jdk1.8.0_201说明：修改为自己的JDK路径</code></pre><p><strong>修改hdfs-site.xml</strong></p><pre><code>修改/opt/hadoop/hadoop-2.8.0/etc/hadoop/hdfs-site.xml文件在&lt;configuration&gt;节点内加入配置:&lt;property&gt;&lt;name&gt;dfs.name.dir&lt;/name&gt;&lt;value&gt;/root/hadoop/dfs/name&lt;/value&gt;&lt;description&gt;Path on the local filesystem where theNameNode stores the namespace and transactions logs persistently.&lt;/description&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;dfs.data.dir&lt;/name&gt;&lt;value&gt;/root/hadoop/dfs/data&lt;/value&gt;&lt;description&gt;Comma separated list of paths on the localfilesystem of a DataNode where it should store its blocks.&lt;/description&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;dfs.replication&lt;/name&gt;&lt;value&gt;2&lt;/value&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;dfs.permissions&lt;/name&gt;    &lt;value&gt;false&lt;/value&gt;    &lt;description&gt;need not permissions&lt;/description&gt;&lt;/property&gt;        说明：dfs.permissions配置为false后，可以允许不要检查权限就生成dfs上的文件，方便倒是方便了，但是你需要防止误删除，请将它设置为true，或者直接将该property节点删除，因为默认就是true。</code></pre><p><strong>新建并且修改mapred-site.xml</strong></p><p>在该版本中，有一个名为mapred-site.xml.template的文件，复制该文件，然后改名为mapred-site.xml，命令是：</p><p><code>cp /opt/hadoop/hadoop-2.8.0/etc/hadoop/mapred-site.xml.template     /opt/hadoop/hadoop-2.8.0/etc/hadoop/mapred-site.xml</code>  </p><pre><code>修改这个新建的mapred-site.xml文件，在&lt;configuration&gt;节点内加入配置:&lt;property&gt;    &lt;name&gt;mapred.job.tracker&lt;/name&gt;    &lt;value&gt;master:49001&lt;/value&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;mapred.local.dir&lt;/name&gt;    &lt;value&gt;/root/hadoop/var&lt;/value&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;mapreduce.framework.name&lt;/name&gt;    &lt;value&gt;yarn&lt;/value&gt;&lt;/property&gt;</code></pre><h5 id="修改slaves文件"><a href="#修改slaves文件" class="headerlink" title="修改slaves文件"></a>修改slaves文件</h5><p>修改/opt/hadoop/hadoop-2.8.0/etc/hadoop/slaves文件，将里面的localhost删除，添加如下内容：</p><pre><code>slave1slave2 </code></pre><p>只在master中做修改</p><h5 id="修改yarn-site-xml文件"><a href="#修改yarn-site-xml文件" class="headerlink" title="修改yarn-site.xml文件"></a>修改yarn-site.xml文件</h5><p>修改/opt/hadoop/hadoop-2.8.0/etc/hadoop/yarn-site.xml文件，</p><pre><code>在&lt;configuration&gt;节点内加入配置(注意了，内存根据机器配置越大越好，我这里只配2个G是因为机器不行):&lt;property&gt;        &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;        &lt;value&gt;master&lt;/value&gt;&lt;/property&gt;&lt;property&gt;        &lt;description&gt;The address of the applications manager interface in the RM.&lt;/description&gt;        &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt;        &lt;value&gt;${yarn.resourcemanager.hostname}:8032&lt;/value&gt;&lt;/property&gt;&lt;property&gt;        &lt;description&gt;The address of the scheduler interface.&lt;/description&gt;        &lt;name&gt;yarn.resourcemanager.scheduler.address&lt;/name&gt;        &lt;value&gt;${yarn.resourcemanager.hostname}:8030&lt;/value&gt;&lt;/property&gt;&lt;property&gt;        &lt;description&gt;The http address of the RM web application.&lt;/description&gt;        &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt;        &lt;value&gt;${yarn.resourcemanager.hostname}:8088&lt;/value&gt;&lt;/property&gt;&lt;property&gt;        &lt;description&gt;The https adddress of the RM web application.&lt;/description&gt;        &lt;name&gt;yarn.resourcemanager.webapp.https.address&lt;/name&gt;        &lt;value&gt;${yarn.resourcemanager.hostname}:8090&lt;/value&gt;&lt;/property&gt;&lt;property&gt;        &lt;name&gt;yarn.resourcemanager.resource-tracker.address&lt;/name&gt;        &lt;value&gt;${yarn.resourcemanager.hostname}:8031&lt;/value&gt;&lt;/property&gt;&lt;property&gt;        &lt;description&gt;The address of the RM admin interface.&lt;/description&gt;        &lt;name&gt;yarn.resourcemanager.admin.address&lt;/name&gt;        &lt;value&gt;${yarn.resourcemanager.hostname}:8033&lt;/value&gt;&lt;/property&gt;&lt;property&gt;        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;&lt;/property&gt;&lt;property&gt;        &lt;name&gt;yarn.scheduler.maximum-allocation-mb&lt;/name&gt;        &lt;value&gt;2048&lt;/value&gt;        &lt;discription&gt;每个节点可用内存,单位MB,默认8182MB&lt;/discription&gt;&lt;/property&gt;&lt;property&gt;        &lt;name&gt;yarn.nodemanager.vmem-pmem-ratio&lt;/name&gt;        &lt;value&gt;2.1&lt;/value&gt;&lt;/property&gt;&lt;property&gt;        &lt;name&gt;yarn.nodemanager.resource.memory-mb&lt;/name&gt;        &lt;value&gt;2048&lt;/value&gt;&lt;/property&gt;&lt;property&gt;        &lt;name&gt;yarn.nodemanager.vmem-check-enabled&lt;/name&gt;        &lt;value&gt;false&lt;/value&gt;&lt;/property&gt;    说明：yarn.nodemanager.vmem-check-enabled这个的意思是忽略虚拟内存的检查，如果你是安装在虚拟机上，这个配置很有用，配上去之后后续操作不容易出问题。如果是实体机上，并且内存够多，可以将这个配置去掉。</code></pre><p>然后用 scp命令传到 slave1与slave2中</p><p><img src="image029.png" alt="Hadoop"></p><h2 id="启动hadoop"><a href="#启动hadoop" class="headerlink" title="启动hadoop"></a>启动hadoop</h2><h3 id="在namenode上执行初始化"><a href="#在namenode上执行初始化" class="headerlink" title="在namenode上执行初始化"></a>在namenode上执行初始化</h3><p>因为master是namenode，slave1和slave2都是datanode，所以只需要对master进行初始化操作，也就是对hdfs进行格式化。</p><p>进入到master这台机器的/opt/hadoop/hadoop-2.8.0/bin目录，也就是执行命令：</p><p><code>cd /opt/hadoop/hadoop-2.8.0/bin</code></p><p>执行初始化脚本，也就是执行命令：</p><p><code>./hadoop  namenode  -format</code></p><p>如图：</p><p><img src="image031.png" alt="Hadoop"></p><p> 稍等几秒，不报错的话，即可执行成功，如图：</p><p><img src="image033.png" alt="Hadoop"></p><p>格式化成功后，可以在看到在/root/hadoop/dfs/name/目录多了一个current目录，而且该目录内有一系列文件：</p><p><img src="image035.png" alt="Hadoop"></p><h3 id="在namenode上执行启动命令"><a href="#在namenode上执行启动命令" class="headerlink" title="在namenode上执行启动命令"></a>在namenode上执行启动命令</h3><p>因为master是namenode，slave1和slave2都是datanode，所以只需要再slave2上执行启动命令即可。</p><p>进入到master这台机器的/opt/hadoop/hadoop-2.8.0/sbin目录，也就是执行命令：</p><p><code>cd /opt/hadoop/hadoop-2.8.0/sbin</code></p><p>执行初始化脚本，也就是执行命令：</p><p><code>./start-all.sh</code></p><p>第一次执行上面的启动命令，会需要我们进行交互操作，在问答界面上输入yes回车</p><p>如图：</p><p><img src="image037.png" alt="Hadoop"></p><p><strong>关闭防火墙：</strong></p><p><code>systemctl stop firewalld.service</code></p><p>不关闭防火墙的话，web页面访问不了！！！</p><p>master是我们的namanode，该机器的IP是<code>192.168.236.132</code>，在本地电脑访问如下地址:</p><p><code>http://192.168.236.132:50070/</code></p><p>自动跳转到了overview页面</p><p>如图：</p><p><img src="image039.png" alt="Hadoop"></p><p>在本地浏览器里访问如下地址：</p><p><a href="http://192.168.119.128:8088/" target="_blank" rel="noopener">http://192.168.119.128:8088/</a></p><p>自动跳转到了cluster页面</p><p>如图：</p><p><img src="image041.png" alt="Hadoop"></p><p><strong>Hadoop安装完成！</strong></p><h2 id="报错处理"><a href="#报错处理" class="headerlink" title="报错处理"></a>报错处理</h2><p>想执行hadoop命令，结果报错：hadoop：未找到命令。</p><p>原因是hadoop的安装路径没有加入到当前路径中。解决办法有两个：</p><p>一．进入hadoop的安装目录，在执行hadoop命令时在前面加上：./bin  ./sbin</p><p>二．在/etc/profile文件中添加hadoop的安装路径：</p><p><code>sudo vim /etc/profile</code></p><p>加入：</p><pre><code>export HADOOP_HOME=/opt/hadoop/hadoop-2.8.0/export PATH=$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$PATH</code></pre><p>保存后退出。</p><p>执行：</p><p><code>source /etc/profile</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;此文为在centos7下安装Hadoop集群&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前期准备&quot;&gt;&lt;a href=&quot;#前期准备&quot; class=&quot;headerlink&quot; title=&quot;前期准备&quot;&gt;&lt;/a&gt;前期准备&lt;/h2&gt;&lt;blockqu
      
    
    </summary>
    
      <category term="Liunx" scheme="http://yoursite.com/categories/Liunx/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/categories/Liunx/Hadoop/"/>
    
    
      <category term="Liunx" scheme="http://yoursite.com/tags/Liunx/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>初识Scala</title>
    <link href="http://yoursite.com/2019/08/08/%E5%88%9D%E8%AF%86Scala/"/>
    <id>http://yoursite.com/2019/08/08/初识Scala/</id>
    <published>2019-08-08T11:33:24.000Z</published>
    <updated>2019-08-08T12:01:43.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Scala概述"><a href="#Scala概述" class="headerlink" title="Scala概述"></a>Scala概述</h2><h3 id="学习Scala的原因"><a href="#学习Scala的原因" class="headerlink" title="学习Scala的原因"></a>学习Scala的原因</h3><ol><li><p>Spark—新一代内存级大数据计算框架，是大数据的重要内容。</p></li><li><p>Spark就是使用Scala编写的。因此为了更好的学习Spark, 需要掌握Scala这门语言。</p></li><li><p>Scala 是 Scalable Language 的简写，是一门多范式(范式/编程方式[面向对象/函数式编程])的编程语言</p></li><li><p>联邦理工学院洛桑（EPFL）的Martin Odersky于2001年开始设计Scala</p></li><li><p>Spark的兴起，带动Scala语言的发展！</p></li></ol><h3 id="Scala语言的特点"><a href="#Scala语言的特点" class="headerlink" title="Scala语言的特点"></a>Scala语言的特点</h3><blockquote><p>Scala 是一门以 java 虚拟机（JVM）为运行环境并将面向对象和函数式编程的最佳特性结合在一起的静态类型编程语言。</p></blockquote><ol><li>Scala 是一门多范式 (multi-paradigm) 的编程语言，Scala 支持面向对象和函数式编程</li><li>Scala 源代码(.scala)会被编译成 Java 字节码(.class)，然后运行于 JVM 之上，并可以调用现有的<br>Java 类库，实现两种语言的无缝对接。</li><li>scala 单作为一门语言来看， 非常的简洁高效（三元运算， ++ ， –）</li><li>Scala 在设计时，马丁·奥德斯基 是参考了 Java 的设计思想，可以说 Scala 是源于 java，同时马丁·奥德斯基 也加入了自己的思想，将函数式编程语言的特点融合到 JAVA 中</li></ol><h3 id="Scala的转义字符"><a href="#Scala的转义字符" class="headerlink" title="Scala的转义字符"></a>Scala的转义字符</h3><ol><li>\t ：一个制表符</li><li>\n ：换行符</li><li>\ ：一个 \</li><li>\” : 一个 “</li><li>\r ： 一个回车</li></ol><h3 id="Scala语言输出的三种方式"><a href="#Scala语言输出的三种方式" class="headerlink" title="Scala语言输出的三种方式"></a>Scala语言输出的三种方式</h3><ol><li>字符串通过+号连接（类似 java）。</li><li>printf 用法 （类似 C 语言）字符串通过 % 传值。</li><li>字符串通过$引用(类似 PHP）。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">object TestPrint &#123;</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">main</span><span class="params">(args: Array[String])</span>: Unit </span>= &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name : String = <span class="string">"tom"</span> <span class="keyword">var</span> sal : Double = <span class="number">1.2</span> println(<span class="string">"hello"</span> + sal + name )</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使 用 格 式 化 的 方 式</span></span><br><span class="line"></span><br><span class="line"><span class="function">printf <span class="title">printf</span><span class="params">(<span class="string">"name=%s sal=%f\n"</span>, name, sal)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//使用$引用的方式，输出变量，类似 php</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">println</span><span class="params">(s<span class="string">"第三种方式 name=$name sal = $&#123;sal + 1&#125;"</span>)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Scala-中的注释类型"><a href="#Scala-中的注释类型" class="headerlink" title="Scala 中的注释类型"></a>Scala 中的注释类型</h3><ol><li>单行注释</li><li>多行注释</li><li>文档注释</li></ol><p>跟Java类似此处就不再赘述</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Scala概述&quot;&gt;&lt;a href=&quot;#Scala概述&quot; class=&quot;headerlink&quot; title=&quot;Scala概述&quot;&gt;&lt;/a&gt;Scala概述&lt;/h2&gt;&lt;h3 id=&quot;学习Scala的原因&quot;&gt;&lt;a href=&quot;#学习Scala的原因&quot; class=&quot;head
      
    
    </summary>
    
      <category term="Liunx" scheme="http://yoursite.com/categories/Liunx/"/>
    
      <category term="Scala" scheme="http://yoursite.com/categories/Liunx/Scala/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala的安装</title>
    <link href="http://yoursite.com/2019/08/08/Scala%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2019/08/08/Scala的安装/</id>
    <published>2019-08-08T09:29:24.000Z</published>
    <updated>2019-08-08T11:58:19.395Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备安装"><a href="#准备安装" class="headerlink" title="准备安装"></a>准备安装</h2><p>首先在官网下载好scala以后，安装在hadoop目录下</p><pre><code>cd /opt/hadooptar -zxvf scala-2.12.8.tgz</code></pre><h2 id="进入环境变量"><a href="#进入环境变量" class="headerlink" title="进入环境变量"></a>进入环境变量</h2><p><code>vim /etc/profile</code></p><pre><code>#scalaexport SCALA_HOME=/opt/hadoop/scala-2.12.8export PATH=$PATH:$SCALA_HOME/bin</code></pre><p><code>source /etc/profile</code><br><strong>保存</strong></p><p>在相应的slave1，与slave2中也进行相应修改</p><h2 id="安装成功"><a href="#安装成功" class="headerlink" title="安装成功"></a>安装成功</h2><p><img src="1.png" alt="Scala"></p><h2 id="将scala分发到其他节点上"><a href="#将scala分发到其他节点上" class="headerlink" title="将scala分发到其他节点上"></a>将scala分发到其他节点上</h2><pre><code>scp -r scala-2.12.8 root@slave1:/opt/hadoop/scp -r scala-2.12.8 root@slave2:/opt/hadoop/</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;准备安装&quot;&gt;&lt;a href=&quot;#准备安装&quot; class=&quot;headerlink&quot; title=&quot;准备安装&quot;&gt;&lt;/a&gt;准备安装&lt;/h2&gt;&lt;p&gt;首先在官网下载好scala以后，安装在hadoop目录下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd /opt/hadoop
tar
      
    
    </summary>
    
      <category term="Liunx" scheme="http://yoursite.com/categories/Liunx/"/>
    
      <category term="Scala" scheme="http://yoursite.com/categories/Liunx/Scala/"/>
    
    
      <category term="Liunx" scheme="http://yoursite.com/tags/Liunx/"/>
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Liunx中tar命令的使用</title>
    <link href="http://yoursite.com/2019/08/08/Liunx%E4%B8%ADtar%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/08/08/Liunx中tar命令的使用/</id>
    <published>2019-08-08T09:06:25.000Z</published>
    <updated>2019-08-08T09:25:46.109Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>把常用的tar解压命令总结下，当作备忘：</p></blockquote><hr><h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><pre><code>-c: 建立压缩档案-x：解压-t：查看内容-r：向压缩归档文件末尾追加文件-u：更新原压缩包中的文件</code></pre><p>这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。</p><pre><code>-z：有gzip属性的-j：有bz2属性的-Z：有compress属性的-v：显示所有过程-O：将文件解开到标准输出</code></pre><h3 id="下面的参数-f是必须的"><a href="#下面的参数-f是必须的" class="headerlink" title="下面的参数-f是必须的"></a>下面的参数-f是必须的</h3><blockquote><p>-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。</p></blockquote><p><code>tar -cf all.tar *.jpg</code></p><p>这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。</p><p><code>tar -rf all.tar *.gif</code></p><p>这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。</p><p><code>tar -uf all.tar logo.gif</code></p><p>这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。</p><p><code>tar -tf all.tar</code></p><p>这条命令是列出all.tar包中所有文件，-t是列出文件的意思</p><p><code>tar -xf all.tar</code></p><p>这条命令是解出all.tar包中所有文件，-x是解开的意思</p><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><p>将目录里所有jpg文件打包成tar.jpg</p><p><code>tar –cvf jpg.tar *.jpg</code></p><p>将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz</p><p><code>tar –czf jpg.tar.gz *.jpg</code></p><p>将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2</p><p><code>tar –cjf jpg.tar.bz2 *.jpg</code></p><p>将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z</p><p><code>tar –cZf jpg.tar.Z *.jpg</code></p><p>rar格式的压缩，需要先下载rar for linux</p><p><code>rar a jpg.rar *.jpg</code></p><p>zip格式的压缩，需要先下载zip for linux</p><p><code>zip jpg.zip *.jpg</code></p><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><p>解压 tar包</p><p><code>tar –xvf file.tar</code></p><p>解压tar.gz</p><p><code>tar -xzvf file.tar.gz</code></p><p>解压 tar.bz2</p><p><code>tar -xjvf file.tar.bz2</code></p><p>解压tar.Z</p><p><code>tar –xZvf file.tar.Z</code></p><p>解压rar</p><p><code>unrar e file.rar</code></p><p>解压zip</p><p><code>unzip file.zip</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code>*.tar 用 tar –xvf 解压*.gz 用 gzip -d或者gunzip 解压*.tar.gz和*.tgz 用 tar –xzf 解压*.bz2 用 bzip2 -d或者用bunzip2 解压*.tar.bz2用tar –xjf 解压*.Z 用 uncompress 解压*.tar.Z 用tar –xZf 解压*.rar 用 unrar e解压*.zip 用 unzip 解压</code></pre><blockquote><p>linux下最常用的打包程序就是tar了，使用tar程序打出来的包我们常称为tar包，tar包文件的命令通常都是<br>以.tar结尾的。生成tar包后，就可以用其它的程序来进行压缩。</p></blockquote><h3 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h3><ol><li>命令格式:</li></ol><p><code>tar[必要参数][选择参数][文件]</code></p><ol start="2"><li>命令功能：</li></ol><p>用来压缩和解压文件。tar本身不具有压缩功能。他是调用压缩功能实现的</p><ol start="3"><li>命令参数：</li></ol><p><strong>必要参数有如下：</strong></p><pre><code>-A 新增压缩文件到已存在的压缩-B 设置区块大小-c 建立新的压缩文件-d 记录文件的差别-r 添加文件到已经压缩的文件-u 添加改变了和现有的文件到已经存在的压缩文件-x 从压缩的文件中提取文件-t 显示压缩文件的内容-z 支持gzip解压文件-j 支持bzip2解压文件-Z 支持compress解压文件-v 显示操作过程-l 文件系统边界设置-k 保留原有文件不覆盖-m 保留文件不被覆盖-W 确认压缩文件的正确性可选参数如下：-b 设置区块数目-C 切换到指定目录-f 指定压缩文件--help 显示帮助信息--version 显示版本信息</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;把常用的tar解压命令总结下，当作备忘：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;tar&quot;&gt;&lt;a href=&quot;#tar&quot; class=&quot;headerlink&quot; title=&quot;tar&quot;&gt;&lt;/a&gt;tar&lt;/h2&gt;&lt;pre&gt;&lt;cod
      
    
    </summary>
    
      <category term="Liunx" scheme="http://yoursite.com/categories/Liunx/"/>
    
    
      <category term="Liunx" scheme="http://yoursite.com/tags/Liunx/"/>
    
  </entry>
  
  <entry>
    <title>Java变量类型</title>
    <link href="http://yoursite.com/2019/08/02/Java%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/08/02/Java变量类型/</id>
    <published>2019-08-02T11:00:44.000Z</published>
    <updated>2019-08-08T09:40:49.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量的分类"><a href="#变量的分类" class="headerlink" title="变量的分类"></a>变量的分类</h2><h3 id="按数据类型分类"><a href="#按数据类型分类" class="headerlink" title="按数据类型分类"></a>按数据类型分类</h3><p><strong>详细说明：</strong></p><ol><li>整型：</li></ol><ul><li>byte(1字节=8bit)</li><li>short(2字节)</li><li>int(4字节)</li><li>long(8字节)</li></ul><p>① byte范围：-128 ~ 127</p><p>② 声明long型变量，必须以”l”或”L”结尾</p><p>③ 通常，定义整型变量时，使用int型。</p><p>④整型的常量，默认类型是：int型</p><ol start="2"><li>浮点型：float(4字节) \ double(8字节)</li></ol><p>① 浮点型，表示带小数点的数值</p><p>② float表示数值的范围比long还大</p><p>③ 定义float类型变量时，变量要以”f”或”F”结尾</p><p>④ 通常，定义浮点型变量时，使用double型。</p><p>⑤ 浮点型的常量，默认类型为：double</p><ol start="3"><li>字符型：char (1字符=2字节)<br>① 定义char型变量，通常使用一对’’,内部只能写一个字符<br>② 表示方式：</li></ol><ul><li>声明一个字符</li><li>转义字符</li><li>直接使用 Unicode 值来表示字符型常量</li></ul><ol start="4"><li>布尔型：boolean</li></ol><p>① 只能取两个值之一：true 、 false</p><p>② 常常在条件判断、循环结构中使用</p><h2 id="定义变量的格式"><a href="#定义变量的格式" class="headerlink" title="定义变量的格式"></a>定义变量的格式</h2><p>数据类型  变量名 = 变量值;</p><p>或</p><p>数据类型  变量名;</p><p>变量名 = 变量值;</p><h3 id="变量使用的注意点"><a href="#变量使用的注意点" class="headerlink" title="变量使用的注意点"></a>变量使用的注意点</h3><p>① 变量必须先声明，后使用</p><p>② 变量都定义在其作用域内。在作用域内，它是有效的。换句话说，出了作用域，就失效了</p><p>③ 同一个作用域内，不可以声明两个同名的变量</p><h3 id="基本数据类型变量间运算规则"><a href="#基本数据类型变量间运算规则" class="headerlink" title="基本数据类型变量间运算规则"></a>基本数据类型变量间运算规则</h3><p>涉及到的基本数据类型：除了boolean之外的其他7种</p><p>自动类型转换(只涉及7种基本数据类型）</p><p><strong>结论：</strong></p><blockquote><p>当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。</p></blockquote><p>byte 、char 、short –&gt; int –&gt; long –&gt; float –&gt; double</p><p>特别的：当byte、char、short三种类型的变量做运算时，结果为<strong>int型</strong></p><p>说明：此时的容量大小指的是，表示数的范围的大和小。比如：float容量要大于long的容量</p><h3 id="强制类型转换-只涉及7种基本数据类型）：自动类型提升运算的逆运算"><a href="#强制类型转换-只涉及7种基本数据类型）：自动类型提升运算的逆运算" class="headerlink" title="强制类型转换(只涉及7种基本数据类型）：自动类型提升运算的逆运算"></a>强制类型转换(只涉及7种基本数据类型）：自动类型提升运算的逆运算</h3><ol><li>需要使用强转符：()</li><li>注意点：强制类型转换，可能导致精度损失。</li></ol><h2 id="String与8种基本数据类型间的运算"><a href="#String与8种基本数据类型间的运算" class="headerlink" title="String与8种基本数据类型间的运算"></a>String与8种基本数据类型间的运算</h2><ol><li>String属于引用数据类型,翻译为：字符串</li><li>声明String类型变量时，使用一对””</li><li>String可以和8种基本数据类型变量做运算，且运算只能是连接运算：+</li><li>运算的结果仍然是String类型</li></ol><p><strong>避免：</strong></p><pre><code>String s = 123;//编译错误String s1 = &quot;123&quot;;int i = (int)s1;//编译错误</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;变量的分类&quot;&gt;&lt;a href=&quot;#变量的分类&quot; class=&quot;headerlink&quot; title=&quot;变量的分类&quot;&gt;&lt;/a&gt;变量的分类&lt;/h2&gt;&lt;h3 id=&quot;按数据类型分类&quot;&gt;&lt;a href=&quot;#按数据类型分类&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>什么是环境变量</title>
    <link href="http://yoursite.com/2019/08/02/%E4%BB%80%E4%B9%88%E6%98%AF%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>http://yoursite.com/2019/08/02/什么是环境变量/</id>
    <published>2019-08-02T11:00:28.000Z</published>
    <updated>2019-08-10T02:48:05.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相信大家初学java时，肯定会涉及到“配置环境变量”，而在网上搜索大多是教我们如何如配置，真正说明为什么要去配置环境变量的不多。</p><p>不管在windows里还是liunx里都少不了环境变量的配置，一键Copy是解决不了问题的，还可能会出现各种各样的问题，如果我们搞清楚原理，就会方便许多。</p><p>今天我们就以java环境变量来了解，什么是环境变量以及为什么要配置。</p><h2 id="什么是环境变量"><a href="#什么是环境变量" class="headerlink" title="什么是环境变量"></a>什么是环境变量</h2><h3 id="环境变量（Environment-Variable-）"><a href="#环境变量（Environment-Variable-）" class="headerlink" title="环境变量（Environment Variable ）"></a>环境变量（Environment Variable ）</h3><p>环境变量是在操作系统中一个具有特定名字的对象，它包含了一个或者多个应用程序所将使用到的信息。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><blockquote><p>可以随意给其赋值的一个存储单元</p></blockquote><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>例如jvm这些都属于小软件，它们处于<strong>操作系统</strong>这个大软件中。</p><h4 id="环境变量的作用"><a href="#环境变量的作用" class="headerlink" title="环境变量的作用"></a>环境变量的作用</h4><p>变量在任何程序中的作用都是“被赋值/被取值”！这个全局变量操作系统可以使用，其内的小软件也可以使用！</p><h4 id="环境变量有哪些"><a href="#环境变量有哪些" class="headerlink" title="环境变量有哪些"></a>环境变量有哪些</h4><ol><li>在Windows中，是由可视化的窗口模式展现出来的</li></ol><p><img src="1.png" alt="Windowds"></p><ol start="2"><li>在Linux中</li></ol><p><strong>设置：</strong></p><p>在 <code>/etc/profile</code>文件中设置，<code>export</code>的意思就是将局部变量设置为环境变量。现有的变量是被这样一行代码设置的：</p><p><code>export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL</code></p><p>这几个环境变量已经有一些默认值了，不过我们可以追加内容，比如修改PATH：</p><pre><code># : 的意思是并列PATH = /abc/def:$PATH</code></pre><p><strong>查看：</strong></p><p>查看全部，使用<code>env</code>命令即可。</p><p>查看单个，可以使用<code>echo</code>：如<code>echo $JAVA_HOME。</code></p><h2 id="在JAVA中"><a href="#在JAVA中" class="headerlink" title="在JAVA中"></a>在JAVA中</h2><p>我们知道什么是环境变量以后，在java中会具体怎么用到呢？</p><h3 id="常见的Java相关环境变量及其作用"><a href="#常见的Java相关环境变量及其作用" class="headerlink" title="常见的Java相关环境变量及其作用"></a>常见的Java相关环境变量及其作用</h3><h4 id="PATH"><a href="#PATH" class="headerlink" title="PATH"></a>PATH</h4><p>PATH是操作系统用的，用来指定操作系统需要使用到的可执行程序的位置。对于Java来说，通常需要把JDK的bin目录添加进入PATH中，这样你就可以在任意目录下使用bin下面的可执行程序，如javac.exe、java.exe等。</p><p><strong>这个变量一定要保证将JRE/JDK的bin纳入其中。</strong></p><pre><code>JDK,JRE，JVM三者之间的关系，以及JDK，JRE包含的主要结构有哪些JDK = JRE + Java的开发工具（javac.exe,java.exe,javadoc.exe）JRD = JVM + Java核心类库</code></pre><h4 id="JAVA-HOME"><a href="#JAVA-HOME" class="headerlink" title="JAVA_HOME"></a>JAVA_HOME</h4><p>JAVA_HOME是一个约定，通常它指的是JDK的目录。如果需要JDK的话，大部分程序会默认去环境变量中取JAVA_HOME这个变量。</p><p><strong>很重要，一些java开发的工具例如IDEA就需要。</strong></p><h4 id="CLASSPATH"><a href="#CLASSPATH" class="headerlink" title="CLASSPATH"></a>CLASSPATH</h4><p>在于告诉Java执行环境，在哪些目录下可以找到我们所要执行的Java程序所需要的类或者包。不过在JDK1.5之后的版本完全可以不用设置classpath环境变量就能正常运行程序。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li><p>需要在操作系统下设置的变量：</p><p> PATH中包含JRE/JDK的bin目录。<br> JAVA_HOME</p></li><li><p>一条命令语句包含命令本身（操作）和操作对象：Command + object，编译和运行Java程序必须经过两个步骤：</p></li></ol><ul><li><p>将源文件编译成字节码 （javac）</p></li><li><p>执行平台无关的字节码程序（java）</p></li></ul><p>那么错误可能会有两种情况，一是没有找到命令，二是没有找到命令所要操作的文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;相信大家初学java时，肯定会涉及到“配置环境变量”，而在网上搜索大多是教我们如何如配置，真正说明为什么要去配置环境变量的不多。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Centos7下的JDK安装</title>
    <link href="http://yoursite.com/2019/07/31/Centos7%E4%B8%8B%E7%9A%84JDK%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2019/07/31/Centos7下的JDK安装/</id>
    <published>2019-07-31T11:15:56.000Z</published>
    <updated>2019-08-02T11:13:18.623Z</updated>
    
    <content type="html"><![CDATA[<h2 id="卸载系统自带OpenJDK以及相关的java文件"><a href="#卸载系统自带OpenJDK以及相关的java文件" class="headerlink" title="卸载系统自带OpenJDK以及相关的java文件"></a>卸载系统自带OpenJDK以及相关的java文件</h2><h3 id="查看系统自带jdk版本信息"><a href="#查看系统自带jdk版本信息" class="headerlink" title="查看系统自带jdk版本信息"></a>查看系统自带jdk版本信息</h3><p><code>java -version</code></p><p>查看当前系统自带的open jdk版本信息</p><h3 id="查找要删除的jdk文件"><a href="#查找要删除的jdk文件" class="headerlink" title="查找要删除的jdk文件"></a>查找要删除的jdk文件</h3><p>输入</p><p><code>rpm -qa | grep java</code></p><p>查看包含java字符串的文件，其中删除类似下面这四个文件（不一定是四个）</p><pre><code>java-1.7.0-openjdk-1.7.0.111-2.6.7.8.el7.x86_64java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64java-1.8.0-openjdk-headless-1.8.0.102-4.b14.el7.x86_64java-1.7.0-openjdk-headless-1.7.0.111-2.6.7.8.el7.x86_64</code></pre><p>包含noarch的文件不必删除，如下：</p><pre><code>python-javapackages-3.4.1-11.el7.noarchtzdata-java-2016g-2.el7.noarchjavapackages-tools-3.4.1-11.el7.noarch</code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除的具体命令如下：</p><pre><code>rpm -e --nodeps java-1.7.0-openjdk-1.7.0.111-2.6.7.8.el7.x86_64rpm -e --nodeps java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64rpm -e --nodeps java-1.8.0-openjdk-headless-1.8.0.102-4.b14.el7.x86_64rpm -e --nodeps java-1.7.0-openjdk-headless-1.7.0.111-2.6.7.8.el7.x86_64</code></pre><p>执行完以上步骤后可以再次使用java -version查看是否已经删除成功。</p><p><img src="1.png" alt></p><h2 id="下载最新稳定版JDK"><a href="#下载最新稳定版JDK" class="headerlink" title="下载最新稳定版JDK"></a>下载最新稳定版JDK</h2><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><blockquote><p><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p></blockquote><p><img src="2.png" alt></p><h3 id="解压JDK"><a href="#解压JDK" class="headerlink" title="解压JDK"></a>解压JDK</h3><p>在命令窗口键入（在特定的文件录下，如/opt/java）:</p><p><code>tar -zxvf jdk-8u144-linux-x64.tar.gz</code></p><h3 id="配置JDK环境变量"><a href="#配置JDK环境变量" class="headerlink" title="配置JDK环境变量"></a>配置JDK环境变量</h3><ol><li>编辑全局变量</li></ol><p>命令行输入：</p><p><code>vim /etc/profile</code></p><p>在文本最后一行添加如下:</p><pre><code>#java environmentexport JAVA_HOME=/opt/java/jdk1.8.0_201export CLASSPATH=.:${JAVA_HOME}/jre/lib/rt.jar:${JAVA_HOME}/lib/dt.jar:${JAVA_HOME}/lib/tools.jarexport PATH=$PATH:${JAVA_HOME}/bin</code></pre><p><strong>保存并退出编辑。</strong></p><ol start="2"><li>让设置的环境变量生效</li></ol><p><code>source /etc/profile</code></p><ol start="3"><li>检查是否配置成功</li></ol><p><code>java -version</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;卸载系统自带OpenJDK以及相关的java文件&quot;&gt;&lt;a href=&quot;#卸载系统自带OpenJDK以及相关的java文件&quot; class=&quot;headerlink&quot; title=&quot;卸载系统自带OpenJDK以及相关的java文件&quot;&gt;&lt;/a&gt;卸载系统自带OpenJDK以
      
    
    </summary>
    
      <category term="Liunx" scheme="http://yoursite.com/categories/Liunx/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/categories/Liunx/Hadoop/"/>
    
    
      <category term="Liunx" scheme="http://yoursite.com/tags/Liunx/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Centos7下NAT设置静态ip</title>
    <link href="http://yoursite.com/2019/07/30/Centos7%E4%B8%8BNAT%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81ip/"/>
    <id>http://yoursite.com/2019/07/30/Centos7下NAT设置静态ip/</id>
    <published>2019-07-30T11:23:49.000Z</published>
    <updated>2019-07-30T12:00:54.597Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>在VMware下安装Centos7 以后，选择NAT模式</p><p>查看IP地址</p><p><code>ip addr</code></p><p><img src="1.png" alt></p><p>现在我的ip地址是dhcp动态分配出的，地址为<strong>192.168.0.128</strong>，网卡名字为<strong>ens33</strong></p><p>点击VMware Workstation 编辑下的<strong>虚拟网络编辑器</strong></p><p><img src="2.png" alt></p><p>在里面我们可以看到虚拟网卡的信息</p><p>点击 <strong>更改设置</strong></p><p><img src="3.png" alt></p><p>点击Vmnet8网卡，将子网ip改为自己想要的ip地址类型，这里我修改的是192.168.0.0</p><p>然后点击NAT设置，将网关设置为192.168.0.253</p><p><img src="4.png" alt></p><p><img src="5.png" alt></p><p><strong>保存退出。</strong></p><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>在/etc/sysconfig/network-scripts/下找到网卡配置文件 <strong>ens33</strong></p><p><code>vim ifcfg-ens33</code></p><p>添加静态ip的配置项</p><pre><code>TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=static #将dhcp改为staticDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens33UUID=27046f8e-9615-376c-b4d4-36646661dbe3ONBOOT=yes     #开机自启网卡AUTOCONNECT_PRIORITY=-999IPADDR=192.168.0.1       #静态ip （添加）   NETMASK=255.255.255.0    #子网掩码GATEWAY=192.168.0.253    #默认网关（刚才在配置项中设置的网关）DNS1=192.168.0.253       #DNS设置与默认网关相同即可PREFIX=24</code></pre><p><strong>保存</strong></p><h2 id="重启网络服务"><a href="#重启网络服务" class="headerlink" title="重启网络服务"></a>重启网络服务</h2><p><code>service network restart</code></p><h2 id="检查网络"><a href="#检查网络" class="headerlink" title="检查网络"></a>检查网络</h2><p><img src="6.png" alt></p><p>可以看到，这里我的地址就变成了192.168.0.1</p><ul><li>查看是否可以连通外网<br><code>ping www.baidu.com</code></li></ul><p><img src="7.png" alt></p><p>外网也是可以ping通的，这样我们的静态ip就设置完成了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前期准备&quot;&gt;&lt;a href=&quot;#前期准备&quot; class=&quot;headerlink&quot; title=&quot;前期准备&quot;&gt;&lt;/a&gt;前期准备&lt;/h2&gt;&lt;p&gt;在VMware下安装Centos7 以后，选择NAT模式&lt;/p&gt;
&lt;p&gt;查看IP地址&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ip add
      
    
    </summary>
    
      <category term="Liunx" scheme="http://yoursite.com/categories/Liunx/"/>
    
    
      <category term="Liunx" scheme="http://yoursite.com/tags/Liunx/"/>
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Github学习笔记</title>
    <link href="http://yoursite.com/2019/07/17/Github%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/07/17/Github学习笔记/</id>
    <published>2019-07-17T11:34:58.000Z</published>
    <updated>2019-07-21T11:09:16.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为一个码代码的萌新，想要学习更前沿更丰富的代码就得来全球最大的开源社区啦！:)</p><p>但是网上的参考资料太多太复杂，我就一边学一边把自己的学习过程整理下来，方便日后复习查看。</p><h1 id="什么是GitHub"><a href="#什么是GitHub" class="headerlink" title="什么是GitHub"></a>什么是GitHub</h1><p>github是一个基于git的代码托管平台，付费用户可以建私人仓库，我们一般的免费用户只能使用公共仓库，也就是代码要公开。<br>Github 由Chris Wanstrath, PJ Hyett 与Tom Preston-Werner三位开发者在2008年4月创办。迄今拥有59名全职员工，主要提供基于git的版本托管服务。</p><p>git是一个版本控制工具，github是一个用git做版本控制的项目托管平台。</p><h1 id="Why-GitHub"><a href="#Why-GitHub" class="headerlink" title="Why GitHub"></a>Why GitHub</h1><p>Git 是一款免费的、开源的、分布式的版本控制系统。旨在快速高效地处理无论规模大小的任何软件工程。</p><p>每一个 Git克隆 都是一个完整的文件库，含有全部历史记录和修订追踪能力，不依赖于网络连接或中心服务器。其最大特色就是“分支”及“合并”操作非常快速、简便。</p><h1 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h1><h2 id="注册GitHub账号"><a href="#注册GitHub账号" class="headerlink" title="注册GitHub账号"></a>注册GitHub账号</h2><p><img src="1.png" alt></p><p>由于我已经有一个账号，大家没有的话得从头开始创建，点击Create an account即可。</p><h2 id="填写基本信息"><a href="#填写基本信息" class="headerlink" title="填写基本信息"></a>填写基本信息</h2><p>填写好自己的基本信息，点击创建就可以拥有一个崭新的GitHub账号</p><p><img src="2.png" alt></p><h2 id="创建属于自己的工程"><a href="#创建属于自己的工程" class="headerlink" title="创建属于自己的工程"></a>创建属于自己的工程</h2><p><img src="3.png" alt></p><p>登录进入自己的GitHub账号后如上图所示</p><p><img src="4.png" alt></p><p>点击箭头所指区域进入<strong>个人中心</strong></p><p><img src="5.png" alt></p><p>点击绿色的小方块</p><p><img src="6.png" alt></p><p><img src="7.png" alt></p><p><img src="8.png" alt></p><p>可以看到我是2018年10月18日创建的GitHub账号。</p><h2 id="创建第一个工程"><a href="#创建第一个工程" class="headerlink" title="创建第一个工程"></a>创建第一个工程</h2><blockquote><p>The Hello World project is a time-honored tradition in computer programming. It is a simple exercise that gets you started when learning something new. Let’s get started with GitHub!</p></blockquote><h3 id="Step-1-Create-a-Repository"><a href="#Step-1-Create-a-Repository" class="headerlink" title="Step 1. Create a Repository"></a>Step 1. Create a Repository</h3><blockquote><p>A repository is usually used to organize a single project. Repositories can contain folders and files, images, videos, spreadsheets, and data sets – anything your project needs. We recommend including a README, or a file with information about your project. GitHub makes it easy to add one at the same time you create your new repository. It also offers other common options such as a license file.<br>Your hello-world repository can be a place where you store ideas, resources, or even share and discuss things with others.</p></blockquote><p><img src="10.png" alt></p><ol><li>将Repository命名为 Hello World</li><li>填写Description</li><li>选择Public</li><li>选中Initialize with a README</li><li>点击 <strong>Create repository</strong>.</li></ol><p><img src="11.png" alt></p><p><img src="12.png" alt></p><h3 id="Step-2-Create-a-Branch"><a href="#Step-2-Create-a-Branch" class="headerlink" title="Step 2. Create a Branch"></a>Step 2. Create a Branch</h3><ol><li>To create a new branch</li><li>进入新建的Hello World repository中</li><li>点击Branch master选项</li><li>输入readme-edits</li><li>选中下方的蓝色链接</li></ol><p><img src="13.png" alt></p><p><img src="14.png" alt></p><p><img src="15.png" alt></p><blockquote><p>现在你有两个分支master和readme-edits。他们看起来完全相同，但是接下来,我们将添加我们更改的新分支。</p></blockquote><h3 id="Step-3-Make-and-commit-changes"><a href="#Step-3-Make-and-commit-changes" class="headerlink" title="Step 3. Make and commit changes"></a>Step 3. Make and commit changes</h3><p>现在咱们有了master的复制版本，readme-edits 分支，这是一个代码视图，我们可以在这里做一些编辑。</p><p>在GitHub中,保存更改被称为commit 提交。每个提交都有一个关联的提交消息,，这是一个描述解释为什么一个特定的更改。提交信息捕获您的更改的历史,所以其他人可以很方便的看到你做了什么。</p><ol><li>点击README.md文件</li><li>点击铅笔图标右上角的编辑文件的视图</li><li>修改README.md</li><li>点击下方的Commit changes</li></ol><p><img src="16.png" alt></p><p><img src="17.png" alt></p><p><img src="18.png" alt></p><p><img src="19.png" alt></p><p><strong>当然这些改变只会在readme-edits这个分支中改变README.md，并不会影响master</strong></p><h3 id="Step-4-Open-a-Pull-Request"><a href="#Step-4-Open-a-Pull-Request" class="headerlink" title="Step 4. Open a Pull Request"></a>Step 4. Open a Pull Request</h3><p>我修改了你的代码，所以请求（request）你把我修改过的代码拉（pull）回去看看</p><ol><li>点击New pull request</li><li>选择创建的readme-edits分支</li><li>可以查看跟master相比的代码</li><li>查看无误后点击Create Pull Request</li><li>这时你的改变后的代码就到Pull request界面中</li><li>你可以选择是否merge</li></ol><p><img src="20.png" alt></p><p><img src="21.png" alt></p><p><img src="22.png" alt></p><p><img src="23.png" alt></p><p><img src="24.png" alt></p><p><img src="25.png" alt></p><h3 id="Step-5-Merge-your-Pull-Request"><a href="#Step-5-Merge-your-Pull-Request" class="headerlink" title="Step 5. Merge your Pull Request"></a>Step 5. Merge your Pull Request</h3><p>这是本次实验的最后一步，Merge可以将别人给你的Pull Request整合到自己的主界面代码视图中</p><ol><li>点击Merge pull request将改变整合到master中</li><li>整合成功后就可以将readme-edits分支删掉</li></ol><p><img src="26.png" alt></p><p><img src="27.png" alt></p><p><img src="28.png" alt></p><p><img src="29.png" alt></p><h3 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h3><p>我们可以发现，master的README变成了readme-edits分支中的README</p><p><img src="30.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;作为一个码代码的萌新，想要学习更前沿更丰富的代码就得来全球最大的开源社区啦！:)&lt;/p&gt;
&lt;p&gt;但是网上的参考资料太多太复杂，我就一边学一边
      
    
    </summary>
    
      <category term="GitHub" scheme="http://yoursite.com/categories/GitHub/"/>
    
    
      <category term="GitHub" scheme="http://yoursite.com/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>hexo搭建个人博客（二）</title>
    <link href="http://yoursite.com/2019/05/21/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2019/05/21/hexo搭建个人博客（二）/</id>
    <published>2019-05-21T08:58:13.000Z</published>
    <updated>2019-07-18T09:00:08.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="博客部署到GitHub"><a href="#博客部署到GitHub" class="headerlink" title="博客部署到GitHub"></a>博客部署到GitHub</h1><h2 id="如果没有GitHub账号可以参考我的其他文章"><a href="#如果没有GitHub账号可以参考我的其他文章" class="headerlink" title="如果没有GitHub账号可以参考我的其他文章"></a>如果没有GitHub账号可以参考我的其他文章</h2><p>有的话我们就进入到自己GitHub的主页面</p><p><img src="1.png" alt></p><p>点击第一个，我们新建一个仓库,在Repository name里输入自己的用户名.github.io</p><blockquote><p>用户部署个人博客的GitHub仓库<strong>命名必须符合特定要求</strong></p></blockquote><p>例如我的输入是:</p><blockquote><p>PlutoaCharon.github.io</p></blockquote><p><img src="2.png" alt></p><p>点击绿色的Create repository按钮创建新的仓库,出现如下界面说明创建成功!</p><p><img src="3.png" alt></p><h2 id="保留这个页面-在blog所在的路径下-在cmd里输入"><a href="#保留这个页面-在blog所在的路径下-在cmd里输入" class="headerlink" title="保留这个页面,在blog所在的路径下,在cmd里输入"></a>保留这个页面,在blog所在的路径下,在cmd里输入</h2><p><code>cnpm install --save hexo-deployer-git</code></p><p>安装一个<strong>git</strong>的部署插件</p><p><img src="4.png" alt></p><h2 id="在blog目录下的-config-ym文件-我们使用nodepad-打开编辑-或者使用系统自带的笔记本打开也可以"><a href="#在blog目录下的-config-ym文件-我们使用nodepad-打开编辑-或者使用系统自带的笔记本打开也可以" class="headerlink" title="在blog目录下的_config.ym文件,我们使用nodepad++打开编辑,或者使用系统自带的笔记本打开也可以"></a>在blog目录下的_config.ym文件,我们使用nodepad++打开编辑,或者使用系统自带的笔记本打开也可以</h2><p>到最底部可以发现有一个Deployment配置<br>我们在这里做一些配置修改<br>type:  git<br>repo:  <a href="https://github.com/PlutoaCharon/PlutoaCharon.github.io.git" target="_blank" rel="noopener">https://github.com/PlutoaCharon/PlutoaCharon.github.io.git</a><br>branch:  master</p><p><img src="5.png" alt></p><p>repo的地址就是咱们新建的仓库的地址，要输入自己的仓库地址，不要输入我的哦。</p><blockquote><p>注意：要在冒号后面加入空格，否则下一步会出现错误</p></blockquote><p>保存以后在cmd里输入</p><p><code>hexo d</code></p><blockquote><p>d的意思就是deport</p></blockquote><h2 id="输入GitHub的账号密码"><a href="#输入GitHub的账号密码" class="headerlink" title="输入GitHub的账号密码"></a>输入GitHub的账号密码</h2><blockquote><p>我是因为安装了GitHub的桌面版才出现Login界面,如果你们没有安装的话应该是在cmd里输入的</p></blockquote><p><img src="6.png" alt></p><p>成功!</p><p>一开始我们的仓库是空的，当我们刷新的时候会发现多了一些东西，这些就是我们博客生成的内容.</p><p><img src="7.png" alt></p><p>这时我们在网址里输入我们刚才的仓库地址就可以直接访问博客，而且也不用在本地打开了.</p><p><img src="8.png" alt></p><h2 id="hexo-d-免密登录"><a href="#hexo-d-免密登录" class="headerlink" title="hexo d 免密登录"></a>hexo d 免密登录</h2><p>在 user 根目录下新建.netrc文件，填写内容：</p><ol><li>machine github.com</li><li>login username      //username为github账户名 （不是用来登录的邮箱或手机号）</li><li>password password   //password为github账户的密码</li></ol><p>保存之后，再执行 hexo d 时即可直接部署，不用输入账号密码了。</p><p>这样简单的博客就部署就完成了！</p><p>接下来大家可以去网上找一些好看的主题，这里就不在一一赘述了,制作一个自己的风格博客吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;博客部署到GitHub&quot;&gt;&lt;a href=&quot;#博客部署到GitHub&quot; class=&quot;headerlink&quot; title=&quot;博客部署到GitHub&quot;&gt;&lt;/a&gt;博客部署到GitHub&lt;/h1&gt;&lt;h2 id=&quot;如果没有GitHub账号可以参考我的其他文章&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="博客" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="GitHub" scheme="http://yoursite.com/tags/GitHub/"/>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo搭建个人博客（一）</title>
    <link href="http://yoursite.com/2019/05/20/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2019/05/20/hexo搭建个人博客（一）/</id>
    <published>2019-05-20T08:58:13.000Z</published>
    <updated>2019-07-13T10:42:55.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><h2 id="下载Node-js"><a href="#下载Node-js" class="headerlink" title="下载Node js"></a>下载Node js</h2><blockquote><p>官方地址：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a> </p></blockquote><p><img src="1.png" alt></p><p>点击第一个绿色按钮     </p><p><img src="2.png" alt> </p><p>安装过程就是一直下一步就可以了。安装完成之后打开cmd</p><p>键盘按住win+r键，输入cmd打开</p><p><img src="3.png" alt></p><p>输入node -v查看node的版本</p><p><img src="4.png" alt></p><p>npm -v查看包管理器版本</p><p><img src="5.png" alt></p><p>这样安装nodejs的步骤就完成了</p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><blockquote><p>因为hexo是需要nodejs来支持的，上面就是前置步骤</p></blockquote><p>这样咱们来开始真正安装hexo博客的框架</p><p>安装之前，我们需要借助npm包来安装，但是因为咱们国内镜像源安装太慢，所以我们一般是在使用之前，先安装cnpm。这里我们使用npm逆向安装cmpm，使用来自淘宝的源</p><p>在cmd里输入</p><p><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p><p>其中<br><strong>–registry镜像源的指向<br>-g全局安装</strong></p><p><img src="6.png" alt></p><p>安装成功<br>在cmd中输入 cnpm -v查看cnpm的版本</p><p><img src="7.png" alt></p><p>这样cnpm便安装成功了。搭建个人博客的过程更是一个学习的过程，其中有报错的地方很正常，我们在重新执行一遍就可以，不要心急，自己搭建完一个自己的博客成就感是非常高的。</p><p>接下来我们使用cnpm来安装hexo。在cmd中输入</p><p><code>cnpm install -g hexo-cli</code></p><p>使用hexo -v查看版本</p><p><img src="8.png" alt></p><p>hexo我们就安装成功了</p><h1 id="使用hexo正式搭建博客"><a href="#使用hexo正式搭建博客" class="headerlink" title="使用hexo正式搭建博客"></a>使用hexo正式搭建博客</h1><p>现在我在cmd的路径是</p><p><img src="9.png" alt></p><p>我们在该路径里创建一个blog文件夹。在cmd里输入</p><p><code>mkdir blog</code></p><p>打开我的电脑，输入C:\Users\lenovo，可以看到在该路径多了一个blog文件夹<br><img src="10.png" alt></p><blockquote><p>如果我们在搭建过程中出现了一些无法避免的错误，可以把blog的文件删掉，重新来过就可以啦.</p></blockquote><p>在cmd里输入 cd ./blog</p><p><strong>cd就是进入到某个路径</strong></p><p><strong>./指当前路径</strong></p><p>我们进去blog目录之后，我们使用hexo生成我们的博客。</p><p>接下来我们打开管理员的命令提示符，这里的权限更大<br>键盘输入</p><p><code>win+x</code></p><p><img src="11.png" alt></p><p>选择命令提示符（管理员）,进入到我们的blog路径,输入</p><p><code>hexo init</code></p><p><strong>初始化hexo</strong></p><p>报错：</p><p><img src="12.png" alt></p><p>键盘输入ctrl+c 选择N</p><p>重新输入 heox init</p><p><img src="13.png" alt></p><p><strong>成功！</strong></p><p>在cmd里输入 hexo s 启动hexo</p><p><img src="14.png" alt></p><p>我们打开浏览器，输入有下划线的那段网址</p><p><img src="15.png" alt></p><p>可以看到，hexo自动帮我生成了一个hello world文章,里面内容是hexo的新手教程</p><h2 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h2><p>首先我们断开掉hexo，键盘按ctrl+c 输入N</p><p>在cmd里输入hexo n “我的第一篇博客文章”</p><p><img src="16.png" alt></p><p><strong>生成成功</strong></p><p>打开我的电脑，进入C:\Users\lenovo\blog\source_posts\路径里，可以看到里面有两个md文件。</p><p><img src="17.png" alt></p><p>接下来我们在cmd中先清理一下，回到blog文件夹输入</p><p><code>hexo clean</code></p><p><img src="18.png" alt></p><p>然后输入</p><p><code>hexo g</code></p><p><img src="19.png" alt></p><p>然后我们在重新启动一下</p><p>输入</p><p><code>hexo s</code></p><p>进入hexo里以后会出现咱们写的第一篇文章</p><p><img src="20.png" alt></p><hr><p>这样我们的博客就搭建成功了，自定义博客自己下去可以慢慢摸索。<br>刚开始的时候不用着急，博客空空的后面可以慢慢加，只要把博客部署起来那么不久之后就会玩的很熟了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前期准备&quot;&gt;&lt;a href=&quot;#前期准备&quot; class=&quot;headerlink&quot; title=&quot;前期准备&quot;&gt;&lt;/a&gt;前期准备&lt;/h1&gt;&lt;h2 id=&quot;下载Node-js&quot;&gt;&lt;a href=&quot;#下载Node-js&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="博客" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
